# ESP32 ArtNet Controller: Consolidated MCP Knowledge Base
Last updated: 2025-04-19 12:56:34

This document is auto-generated from individual knowledge modules.
Source repository: esp-gpt-i2c
Do not edit this file directly - changes will be overwritten.

## Table of Contents

- [Led Control Module](#led_control_module)
- [Network Module](#network_module)
- [Uart Communication Module](#uart_communication_module)


<a id='led_control_module'></a>

## Led Control Module


## Library Information
The project uses `I2SClocklessLedDriver` for controlling WS2812B LED strips via ESP32's I2S peripheral with DMA.

## Key Features
- Hardware-driven timing eliminates flicker
- Supports multiple strips in parallel
- Resistant to WiFi/BT interruptions 
- Buffer management optimized for memory efficiency

## Initialization Patterns
```cpp
// For a single strip on pin 12
int onePin[1] = { 12 };
driver.initled(NULL, onePin, 1, numLedsPerStrip);

// For multiple strips
int pins[numStrips] = { pin1, pin2, ... };
driver.initled(NULL, pins, numStrips, numLedsPerStrip);
```

## Data Update Methods
```cpp
// Non-blocking update (returns immediately)
driver.showPixels(NO_WAIT);

// Blocking update (waits for completion)
driver.showPixels(WAIT);
```

## Color Modes
1. **ArtNet Mode**: Colors received from network DMX packets
2. **Static Color Mode**: Single RGB color applied to all LEDs
3. **Color Cycle Effects**:
   - Rainbow: Smooth hue transition across strip
   - Pulse: Breathing effect with varying intensity
   - Fire: Realistic fire simulation with random flicker

## Troubleshooting
1. **No LEDs lighting up**:
   - Check power supply (5V, sufficient current)
   - Verify data pin matches configuration
   - Ensure common ground between ESP32 and LEDs
   - Run direct test function to bypass normal code paths

2. **Flickering or unstable colors**:
   - Try WAIT mode for updates
   - Reduce update frequency
   - Isolate power supplies for ESP32 and LEDs
   - Check for signal integrity issues on long runs

3. **Color errors**:
   - Verify RGB order matches LED type
   - Check brightness settings
   - Ensure buffer is properly initialized

## Hardware Considerations
- WS2812B LEDs require 5V power and logic
- ESP32 outputs 3.3V logic (marginal but usually works)
- Each LED can draw up to 60mA at full brightness
- External power recommended for >8 LEDs
- Logic level shifter may improve reliability for long runs

## Recent Fixes
- Fixed LED initialization using proper pin configuration arrays
- Corrected data path for static color mode
- Improved buffer management for different modes
- Added extensive error handling

## Implementation Tips
- Use `WAIT` for critical updates to ensure completion
- Clear buffer before applying new colors
- Apply static colors with secondary verification update
- Use brightness control rather than scaling RGB values

---

<a id='network_module'></a>

## Network Module


## Critical Issue: lwIP TCP/IP Stack Initialization

The ESP32 network stack is prone to the following critical assertion failure:
```
assert failed: tcpip_send_msg_wait_sem IDF/components/lwip/lwip/src/api/tcpip.c:455 (Invalid mbox)
```

### Root Cause Analysis
This occurs because:
1. Network operations attempted before TCP/IP stack is fully initialized
2. Improper initialization sequence for ESP-IDF networking components
3. Race conditions between the main loop and network operations

### Correct Initialization Sequence
```cpp
// 1. Initialize TCP/IP stack components first
esp_err_t err = esp_netif_init();
if (err != ESP_OK) {
  debugLog("TCP/IP stack initialization failed: " + String(esp_err_to_name(err)));
  throw std::runtime_error("TCP/IP stack initialization failed");
}

// 2. Create the default event loop
err = esp_event_loop_create_default();
if (err != ESP_OK) {
  debugLog("Event loop creation failed: " + String(esp_err_to_name(err)));
  throw std::runtime_error("Event loop creation failed");
}

// 3. Set WiFi mode with proper sequence
WiFi.persistent(false);
WiFi.disconnect(true);
delay(200);
WiFi.mode(WIFI_STA);
delay(500); // Critical delay for stability

// 4. Connect with proper error handling
WiFi.begin(ssid, password);
// Add timeout and error handling
```

## Implementation Strategy: Task Isolation

To prevent network failures from affecting the main application:

```cpp
// Create a dedicated task on Core 1 for network initialization
xTaskCreatePinnedToCore(
  networkInitTask,     // Task function
  "NetworkInitTask",   // Task name
  8192,                // Stack size
  NULL,                // Task parameter
  1,                   // Task priority (1 is low)
  &networkTaskHandle,  // Task handle
  1                    // Core to run the task on (Core 1)
);
```

## Failure Recovery Mechanism

```cpp
void disableAllNetworkOperations() {
  // Complete network shutdown sequence
  WiFi.disconnect(true);
  WiFi.mode(WIFI_OFF);

  // Mark as failed to prevent any future attempts
  networkInitFailed = true;

  // Force settings to disable any network functionality
  settings.useArtnet = false;
  settings.useWiFi = false;
  settings.useStaticColor = true;

  // Persist the network failure state
  preferences.begin("led-settings", false);
  preferences.putBool("netFailed", true);
  preferences.end();

  debugLog("CRITICAL: Network stack disabled due to assertion failure");
}
```

## ArtNet Protocol Implementation

The ArtNet protocol implementation handles DMX data over WiFi:

```cpp
// Initialize ArtNet once WiFi is connected
bool artnetStarted = artnet.listen(localIP, 6454);
if (artnetStarted) {
  artnet.setFrameCallback(frameCallbackWrapper);
  artnet.addSubArtnet(settings.startUniverse,
                     settings.numStrips * settings.ledsPerStrip * NB_CHANNEL_PER_LED,
                     UNIVERSE_SIZE,
                     &artnetCallback);
  artnet.setNodeName(settings.nodeName);
}
```

## Web Server Interface

```cpp
// Safe implementation pattern for handling requests
server.on("/", handleRoot);
server.on("/config", HTTP_POST, handleConfig);
server.on("/debug", handleDebugLog);
server.begin();
```

## Network Status Monitoring

```cpp
// Check for WiFi status periodically
if (WiFi.status() == WL_CONNECTED) {
  // Connected - proceed with network operations
} else {
  // Not connected - fall back to standalone mode
  // Optionally attempt reconnection with timeout
  static unsigned long lastReconnectAttempt = 0;
  if (millis() - lastReconnectAttempt > 30000) {
    lastReconnectAttempt = millis();
    WiFi.reconnect();
  }
}
```

## Boot Loop Prevention
- Track boot count in non-volatile storage
- If multiple rapid boots detected, enter safe mode
- Disable network functions in safe mode

## Best Practices
1. Always use try/catch blocks around network operations
2. Implement timeouts for all network operations
3. Provide graceful degradation paths when network fails
4. Keep watchdog timer happy with strategic yield() calls
5. Use a separate task for network operations
6. Persist network failure state to prevent recurring crashes

---

<a id='uart_communication_module'></a>

## Uart Communication Module


## Overview
The UART Communication Bridge provides a bidirectional protocol for external control of the ESP32 ArtNet controller. This allows integration with external hardware like PyPortal displays or other microcontrollers.

## Implementation

### Initialization
```cpp
// Define the UART pin configuration
#define UART_RX_PIN 16  // GPIO pin for UART RX
#define UART_TX_PIN 17  // GPIO pin for UART TX

// Create a UART bridge instance using Serial2
UARTCommunicationBridge uartBridge(Serial2);

// Initialize in setup()
pinMode(UART_RX_PIN, INPUT);
pinMode(UART_TX_PIN, OUTPUT);
Serial2.begin(115200, SERIAL_8N1, UART_RX_PIN, UART_TX_PIN);

// Initialize UART bridge with error handling
bool uartOK = uartBridge.initializeCommunication();
if (uartOK) {
  uartBridge.setCommandCallback(handleUARTCommand);
}
```

## Protocol Structure

### Command Format
```
[START_BYTE][COMMAND][LENGTH][DATA...][CHECKSUM]
```

- **START_BYTE**: Fixed value (0xAA) marking packet start
- **COMMAND**: Command ID byte
- **LENGTH**: Length of DATA section
- **DATA**: Variable length command data
- **CHECKSUM**: Simple checksum for error detection

### Response Format
```
[START_BYTE][COMMAND/ACK/NACK][LENGTH][DATA...][CHECKSUM]
```

## Command Reference

### System Commands
- `CMD_PING (0x01)`: Simple ping to check communication
- `CMD_GET_VERSION (0x02)`: Get firmware version
- `CMD_RESET (0x03)`: Reset the ESP32

### LED Control Commands
- `CMD_SET_MODE (0x10)`: Set LED operation mode
  - Mode 0: ArtNet
  - Mode 1: Static color
  - Mode 2: Color cycle
- `CMD_SET_BRIGHTNESS (0x11)`: Set global brightness
- `CMD_SET_COLOR (0x12)`: Set static color (RGB)
- `CMD_SET_EFFECT (0x13)`: Set effect parameters

### Status Commands
- `CMD_GET_STATUS (0x20)`: Get general system status
- `CMD_GET_NETWORK_STATUS (0x21)`: Get network status
- `CMD_DMX_DATA (0x22)`: DMX data received notification

## Error Handling
- `ERR_NONE (0x00)`: No error
- `ERR_INVALID_CMD (0x01)`: Invalid command
- `ERR_INVALID_PARAM (0x02)`: Invalid parameter
- `ERR_CHECKSUM (0x03)`: Checksum error
- `ERR_BUFFER_OVERFLOW (0x04)`: Buffer overflow
- `ERR_TIMEOUT (0x05)`: Operation timeout

## Command Handling Example
```cpp
void handleUARTCommand(uint8_t cmd, uint8_t *data, uint16_t length) {
  switch (cmd) {
    case CMD_SET_MODE:
      if (length >= 1) {
        uint8_t mode = data[0];
        // Set the appropriate mode
        settings.useArtnet = (mode == 0);
        settings.useStaticColor = (mode == 1);
        settings.useColorCycle = (mode == 2);
        
        // Acknowledge the mode change
        uartBridge.sendCommand(CMD_ACK, &mode, 1);
      }
      break;
      
    case CMD_SET_BRIGHTNESS:
      if (length >= 1) {
        settings.brightness = data[0];
        driver.setBrightness(settings.brightness);
        
        // Acknowledge
        uint8_t brightnessValue = settings.brightness;
        uartBridge.sendCommand(CMD_ACK, &brightnessValue, 1);
      }
      break;
      
    // Other commands...
  }
}
```

## Integration with Main Loop
```cpp
void loop() {
  // Process UART communication with protection
  try {
    uartBridge.update();
  } catch (...) {
    // UART errors shouldn't crash the program
    debugLog("WARNING: UART update failed");
  }
  
  // Rest of the main loop...
}
```

## PyPortal Integration
The UART bridge is designed for easy integration with Adafruit PyPortal for creating an advanced touchscreen controller. The PyPortal would:

1. Display current status and mode information
2. Provide touch controls for LED parameters
3. Show color picker for static color mode
4. Display animations for cycle effects
5. Show network connection status

## Debugging
- Built-in error detection and reporting
- State tracking for protocol integrity
- Timeout handling for unresponsive transactions

## Best Practices
1. Always validate incoming command data
2. Implement proper error handling for all commands
3. Keep UART processing non-blocking
4. Provide acknowledgment for all commands
5. Implement checksums for data integrity

---

## Metadata

- **Generated by**: sync_mcp_knowledge.py
- **Date**: 2025-04-19 12:56:34
- **Source modules**: led_control_module, network_module, uart_communication_module
- **Repository**: esp-gpt-i2c
